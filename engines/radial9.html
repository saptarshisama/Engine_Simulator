<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radial-9 Engine Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
            z-index: 10;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            transition: opacity 0.5s;
        }

        #dyno-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 10px;
            pointer-events: none;
        }

        #dyno-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
    <!-- Import Map for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">
        <h1>Radial-9 Aviation Engine</h1>
        <p>Firing Order: 1-3-5-7-9-2-4-6-8</p>
    </div>
    <div id="loading">Initializing Simulation...</div>

    <div id="dyno-panel">
        <canvas id="dyno-canvas"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- DynoGraph Class (Inlined for local file support) ---
        class DynoGraph {
            constructor(canvasId, config = {}) {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) {
                    console.error(`DynoGraph: Canvas with id '${canvasId}' not found.`);
                    return;
                }
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width = this.canvas.offsetWidth;
                this.height = this.canvas.height = this.canvas.offsetHeight;

                this.history = [];
                this.maxPoints = 200;

                // Configurable curve parameters
                this.peakTorqueRPM = config.peakTorqueRPM || 5000;
                this.maxTorque = config.maxTorque || 400;
                this.maxRPM = config.maxRPM || 8000;
            }

            calculatePower(rpm) {
                if (rpm < 10) return { hp: 0, torque: 0 };

                // Simple parabolic torque curve simulation
                const range = this.maxRPM / 2;
                const dev = (rpm - this.peakTorqueRPM) / range;

                let torque = this.maxTorque * (1 - dev * dev * 0.5);
                if (torque < 0) torque = 0;

                let hp = (torque * rpm) / 5252;

                return { hp, torque };
            }

            update(rpm) {
                if (!this.ctx) return;

                const data = this.calculatePower(rpm);
                this.history.push({ rpm, ...data });
                if (this.history.length > this.maxPoints) this.history.shift();

                this.draw();
            }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);

                // Background Grid
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const y = (this.height / 5) * i;
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.width, y);
                }
                this.ctx.stroke();

                if (this.history.length < 2) return;

                const maxScale = 1200;

                // Draw Torque (Yellow)
                this.ctx.strokeStyle = '#ffaa00';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.history.forEach((p, i) => {
                    const x = (i / this.maxPoints) * this.width;
                    const y = this.height - (p.torque / maxScale) * this.height;
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                });
                this.ctx.stroke();

                // Draw HP (Blue)
                this.ctx.strokeStyle = '#00aaff';
                this.ctx.beginPath();
                this.history.forEach((p, i) => {
                    const x = (i / this.maxPoints) * this.width;
                    const y = this.height - (p.hp / maxScale) * this.height;
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                });
                this.ctx.stroke();

                // Legend / Current Values
                const current = this.history[this.history.length - 1];
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '14px monospace';
                this.ctx.fillText(`RPM: ${Math.round(current.rpm)}`, 10, 20);

                this.ctx.fillStyle = '#ffaa00';
                this.ctx.fillText(`Torque: ${Math.round(current.torque)} ft-lbs`, 10, 40);

                this.ctx.fillStyle = '#00aaff';
                this.ctx.fillText(`Power:  ${Math.round(current.hp)} HP`, 10, 60);
            }

            resize() {
                if (!this.canvas) return;
                this.width = this.canvas.width = this.canvas.offsetWidth;
                this.height = this.canvas.height = this.canvas.offsetHeight;
            }
        }

        // --- Constants & Specs ---
        const SPECS = {
            bore: 5.5,
            stroke: 5.5,
            rodLength: 10.0,
            slaveRodLength: 10.0,
            crankRadius: 2.75,
            masterHubRadius: 2.2,
            cylinderCount: 9,
            deckHeight: 14.0,
        };

        // --- Materials ---
        const MATERIALS = {
            aluminum: new THREE.MeshStandardMaterial({
                color: 0xeeeeee, roughness: 0.3, metalness: 0.6, name: 'Aluminum'
            }),
            steel: new THREE.MeshStandardMaterial({
                color: 0xaaaaaa, roughness: 0.4, metalness: 0.8, name: 'Steel'
            }),
            chrome: new THREE.MeshStandardMaterial({
                color: 0xffffff, roughness: 0.1, metalness: 1.0, name: 'Chrome'
            }),
            glass: new THREE.MeshPhysicalMaterial({
                color: 0xffffff, transmission: 0.98, opacity: 0.15, transparent: true,
                roughness: 0.0, metalness: 0.1, thickness: 0.5, side: THREE.DoubleSide, name: 'Glass'
            }),
            combustion: new THREE.MeshBasicMaterial({
                color: 0xffaa00, transparent: true, opacity: 0.0, blending: THREE.AdditiveBlending, name: 'CombustionGas'
            }),
            castIron: new THREE.MeshStandardMaterial({
                color: 0x333333, roughness: 0.9, metalness: 0.4, name: 'CastIron'
            }),
            coolingFins: new THREE.MeshStandardMaterial({
                color: 0x222222, roughness: 0.8, metalness: 0.3, name: 'CoolingFins'
            }),
            propeller: new THREE.MeshPhysicalMaterial({
                color: 0x111111, roughness: 0.2, metalness: 0.1,
                transparent: true, opacity: 0.9,
                side: THREE.DoubleSide, name: 'Propeller'
            })
        };

        // --- Classes ---

        class Crankshaft {
            constructor(scene) {
                this.group = new THREE.Group();
                this.scene = scene;
                this.createGeometry();
                this.scene.add(this.group);
            }

            createGeometry() {
                const { crankRadius } = SPECS;
                const mat = MATERIALS.steel;

                // Main Shaft
                const shaft = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 8, 32), mat);
                shaft.rotation.x = Math.PI / 2;
                this.group.add(shaft);

                // Crank Throw (Single)
                const throwGroup = new THREE.Group();

                // Web
                const webGeo = new THREE.BoxGeometry(4, 8, 1.5);
                const web = new THREE.Mesh(webGeo, mat);
                web.position.y = -1;
                throwGroup.add(web);

                // Counterweight
                const cwGeo = new THREE.CylinderGeometry(4, 4, 1.5, 32, 1, false, 0, Math.PI);
                const cw = new THREE.Mesh(cwGeo, mat);
                cw.rotation.z = Math.PI;
                cw.rotation.x = Math.PI / 2;
                cw.position.y = -3;
                throwGroup.add(cw);

                // Crank Pin
                const pinGeo = new THREE.CylinderGeometry(1.4, 1.4, 3, 32);
                const pin = new THREE.Mesh(pinGeo, MATERIALS.chrome);
                pin.rotation.x = Math.PI / 2;
                pin.position.y = crankRadius;
                pin.position.z = 1.5;
                throwGroup.add(pin);

                // Front Web
                const web2 = new THREE.Mesh(webGeo, mat);
                web2.position.y = -1;
                web2.position.z = 3;
                throwGroup.add(web2);

                // Front Shaft (Propeller Mount)
                const propShaft = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.0, 6, 32), mat);
                propShaft.rotation.x = Math.PI / 2;
                propShaft.position.z = 6;
                throwGroup.add(propShaft);

                this.group.add(throwGroup);
            }

            update(angle) {
                this.group.rotation.z = angle;
            }
        }

        class MasterRodAssembly {
            constructor(scene) {
                this.scene = scene;
                this.group = new THREE.Group();
                this.scene.add(this.group);

                this.slaveRods = [];
                this.pistons = [];

                this.createGeometry();
            }

            createGeometry() {
                // Master Rod
                this.masterRod = new THREE.Group();
                this.group.add(this.masterRod);

                // Master Hub
                const hubGeo = new THREE.CylinderGeometry(SPECS.masterHubRadius, SPECS.masterHubRadius, 1.5, 32);
                const hub = new THREE.Mesh(hubGeo, MATERIALS.steel);
                hub.rotation.x = Math.PI / 2;
                this.masterRod.add(hub);

                // Master Beam
                const beamGeo = new THREE.BoxGeometry(1.0, SPECS.rodLength, 0.5);
                const beam = new THREE.Mesh(beamGeo, MATERIALS.steel);
                beam.position.y = SPECS.rodLength / 2;
                this.masterRod.add(beam);

                // Slave Pins
                const pinGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.6, 16);

                for (let i = 1; i < 9; i++) {
                    const angle = (i / 9) * Math.PI * 2;
                    const r = SPECS.masterHubRadius - 0.3;
                    const px = Math.sin(angle) * r;
                    const py = Math.cos(angle) * r;

                    const pin = new THREE.Mesh(pinGeo, MATERIALS.chrome);
                    pin.rotation.x = Math.PI / 2;
                    pin.position.set(px, py, 0);
                    this.masterRod.add(pin);
                }

                // Create Pistons & Slave Rods
                const pistonGeo = new THREE.CylinderGeometry(SPECS.bore / 2, SPECS.bore / 2, 3, 32);
                const pistonMat = MATERIALS.aluminum;

                for (let i = 0; i < 9; i++) {
                    const pistonGroup = new THREE.Group();
                    this.group.add(pistonGroup);

                    const piston = new THREE.Mesh(pistonGeo, pistonMat);
                    piston.rotation.x = 0;
                    pistonGroup.add(piston);

                    this.pistons.push(pistonGroup);

                    if (i > 0) {
                        const slaveGroup = new THREE.Group();
                        this.group.add(slaveGroup);

                        const sRodGeo = new THREE.BoxGeometry(0.6, SPECS.slaveRodLength, 0.4);
                        const sRod = new THREE.Mesh(sRodGeo, MATERIALS.steel);
                        sRod.position.y = SPECS.slaveRodLength / 2;
                        slaveGroup.add(sRod);

                        this.slaveRods.push({ group: slaveGroup, index: i });
                    }
                }
            }

            update(crankAngle) {
                const r = SPECS.crankRadius;
                const L = SPECS.rodLength;

                const theta = crankAngle + Math.PI / 2;
                const cx = r * Math.cos(theta);
                const cy = r * Math.sin(theta);

                const piston1Y = cy + Math.sqrt(L * L - cx * cx);

                // Master Rod Position/Rotation
                this.masterRod.position.set(cx, cy, 1.5);

                const dx = 0 - cx;
                const dy = piston1Y - cy;
                const masterAngle = Math.atan2(dy, dx) - Math.PI / 2;

                this.masterRod.rotation.z = masterAngle;

                // Update Master Piston
                this.pistons[0].position.set(0, piston1Y, 1.5);
                this.pistons[0].rotation.z = 0;

                // Update Slave Rods
                this.slaveRods.forEach(slave => {
                    const i = slave.index;
                    const cylAngle = (Math.PI / 2) - (i / 9) * Math.PI * 2;

                    const pinRelAngle = (i / 9) * Math.PI * 2;
                    const rot = this.masterRod.rotation.z;

                    const rHub = SPECS.masterHubRadius - 0.3;
                    const px = Math.sin(pinRelAngle) * rHub;
                    const py = Math.cos(pinRelAngle) * rHub;

                    const wx = px * Math.cos(rot) - py * Math.sin(rot) + cx;
                    const wy = px * Math.sin(rot) + py * Math.cos(rot) + cy;

                    const A = cylAngle;
                    const cosA = Math.cos(A);
                    const sinA = Math.sin(A);

                    const B_quad = -2 * (wx * cosA + wy * sinA);
                    const C_quad = wx * wx + wy * wy - SPECS.slaveRodLength * SPECS.slaveRodLength;

                    const disc = B_quad * B_quad - 4 * C_quad;
                    if (disc < 0) return;

                    const D = (-B_quad + Math.sqrt(disc)) / 2;

                    // Update Piston
                    this.pistons[i].position.set(D * cosA, D * sinA, 1.5);
                    this.pistons[i].rotation.z = A - Math.PI / 2;

                    // Update Slave Rod
                    const Px = D * cosA;
                    const Py = D * sinA;

                    slave.group.position.set(wx, wy, 1.5);

                    const rdx = Px - wx;
                    const rdy = Py - wy;
                    const rodAng = Math.atan2(rdy, rdx) - Math.PI / 2;

                    slave.group.rotation.z = rodAng;
                });
            }
        }

        class CylinderUnit {
            constructor(scene, index) {
                this.scene = scene;
                this.index = index;
                this.group = new THREE.Group();
                this.scene.add(this.group);

                // Radial Position
                const angle = (Math.PI / 2) - (index / 9) * Math.PI * 2;
                const dist = SPECS.deckHeight;

                this.group.position.set(Math.cos(angle) * dist, Math.sin(angle) * dist, 1.5);
                this.group.rotation.z = angle - Math.PI / 2;

                this.createGeometry();
            }

            createGeometry() {
                // Cylinder Barrel
                const barrelGeo = new THREE.CylinderGeometry(SPECS.bore / 2 + 0.5, SPECS.bore / 2 + 0.5, 6, 32);
                const barrel = new THREE.Mesh(barrelGeo, MATERIALS.coolingFins);
                barrel.position.y = -3;
                this.group.add(barrel);

                // Glass Liner
                const glassGeo = new THREE.CylinderGeometry(SPECS.bore / 2 + 0.1, SPECS.bore / 2 + 0.1, 6, 32, 1, true);
                this.glass = new THREE.Mesh(glassGeo, MATERIALS.glass);
                this.glass.position.y = -3;
                this.group.add(this.glass);

                // Combustion Flash
                const flashGeo = new THREE.CylinderGeometry(SPECS.bore / 2, SPECS.bore / 2, 1, 32);
                this.flash = new THREE.Mesh(flashGeo, MATERIALS.combustion);
                this.flash.position.y = 0.5;
                this.group.add(this.flash);

                // Head
                const headGeo = new THREE.BoxGeometry(6, 4, 6);
                const head = new THREE.Mesh(headGeo, MATERIALS.aluminum);
                head.position.y = 2;
                this.group.add(head);

                // Rocker Covers
                const rockerGeo = new THREE.CylinderGeometry(1, 1, 6, 16);
                const rocker = new THREE.Mesh(rockerGeo, MATERIALS.chrome);
                rocker.rotation.z = Math.PI / 2;
                rocker.position.y = 4.5;
                this.group.add(rocker);

                // Pushrod Tubes
                const tubeGeo = new THREE.CylinderGeometry(0.3, 0.3, 8, 8);
                const t1 = new THREE.Mesh(tubeGeo, MATERIALS.chrome);
                t1.position.set(1.5, -2, 2.5);
                this.group.add(t1);
                const t2 = new THREE.Mesh(tubeGeo, MATERIALS.chrome);
                t2.position.set(1.5, -2, -2.5);
                this.group.add(t2);

                // Exhaust Pipe
                const exGeo = new THREE.TorusGeometry(3, 0.8, 8, 16, Math.PI / 2);
                const ex = new THREE.Mesh(exGeo, MATERIALS.steel);
                ex.position.set(-3, 2, 0);
                ex.rotation.y = Math.PI / 2;
                this.group.add(ex);
            }

            update(crankAngle) {
                // Firing offsets for each cylinder
                const fireOffsets = {
                    0: 0, 2: 80, 4: 160, 6: 240, 8: 320,
                    1: 400, 3: 480, 5: 560, 7: 640
                };

                const offset = fireOffsets[this.index];
                let cycleAngle = (crankAngle * (180 / Math.PI) + offset) % 720;
                if (cycleAngle < 0) cycleAngle += 720;

                // Combustion Flash
                if (cycleAngle >= 0 && cycleAngle < 60) {
                    this.flash.material.opacity = 0.8 * (1 - cycleAngle / 60);
                } else {
                    this.flash.material.opacity = 0;
                }
            }
        }

        class EngineSimulation {
            constructor() {
                this.params = {
                    rpm: 90,
                    exploded: 0,
                    opacity: 0.15,
                    autoRotate: false,
                    wireframe: false
                };
                this.crankAngle = 0;
                this.lastTime = 0;
                this.container = document.body;

                this.initScene();
                this.initLights();
                this.initPostProcessing();
                this.initObjects();
                this.initUI();

                this.dyno = new DynoGraph('dyno-canvas', { peakTorqueRPM: 2200, maxTorque: 1500, maxRPM: 3000 });

                document.getElementById('loading').style.opacity = 0;
                this.animate(0);
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x050505);

                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 60);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                this.container.appendChild(this.renderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.target.set(0, 0, 0);

                window.addEventListener('resize', this.onWindowResize.bind(this));
            }

            initLights() {
                const ambientLight = new THREE.AmbientLight(0x333333);
                this.scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
                dirLight.position.set(10, 10, 20);
                dirLight.castShadow = true;
                this.scene.add(dirLight);

                const rimLight = new THREE.SpotLight(0xffaa00, 5.0);
                rimLight.position.set(-20, 20, 10);
                this.scene.add(rimLight);

                const grid = new THREE.GridHelper(100, 100, 0x333333, 0x111111);
                grid.position.y = -20;
                this.scene.add(grid);
            }

            initPostProcessing() {
                this.composer = new EffectComposer(this.renderer);
                const renderPass = new RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.6;
                bloomPass.strength = 0.5;
                bloomPass.radius = 0.4;
                this.composer.addPass(bloomPass);
            }

            initObjects() {
                this.crankshaft = new Crankshaft(this.scene);
                this.masterAssembly = new MasterRodAssembly(this.scene);

                this.cylinders = [];
                for (let i = 0; i < 9; i++) {
                    this.cylinders.push(new CylinderUnit(this.scene, i));
                }

                // Propeller (Improved)
                this.prop = new THREE.Group();
                this.prop.position.z = 8;
                this.scene.add(this.prop);

                // Hub
                const hubGeo = new THREE.CylinderGeometry(2, 2, 4, 32);
                const hub = new THREE.Mesh(hubGeo, MATERIALS.propeller);
                hub.rotation.x = Math.PI / 2;
                this.prop.add(hub);

                // Blades (2 blades)
                const bladeShape = new THREE.Shape();
                bladeShape.moveTo(0, 0);
                bladeShape.bezierCurveTo(2, 5, 4, 15, 2, 25); // Leading edge
                bladeShape.lineTo(-1, 25); // Tip
                bladeShape.bezierCurveTo(-3, 15, -2, 5, 0, 0); // Trailing edge

                const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, { depth: 0.5, bevelEnabled: true, bevelSize: 0.2, bevelThickness: 0.1 });

                // Blade 1
                const blade1 = new THREE.Mesh(bladeGeo, MATERIALS.propeller);
                blade1.position.y = 2;
                blade1.rotation.y = 0.3; // Angle of attack
                this.prop.add(blade1);

                // Blade 2
                const blade2 = new THREE.Mesh(bladeGeo, MATERIALS.propeller);
                blade2.position.y = -2;
                blade2.rotation.z = Math.PI;
                blade2.rotation.y = 0.3; // Same angle of attack direction relative to rotation
                this.prop.add(blade2);
            }

            initUI() {
                const gui = new GUI({ title: 'Engine Controls' });
                gui.add(this.params, 'rpm', 0, 3000).name('RPM');
                gui.add(this.params, 'opacity', 0, 1).name('Glass Opacity').onChange(v => {
                    MATERIALS.glass.opacity = v;
                    MATERIALS.propeller.opacity = Math.max(0.1, v); // Keep prop slightly visible
                });
                gui.add(this.params, 'autoRotate').name('Auto Rotate');
                gui.add(this.params, 'wireframe').name('Wireframe').onChange(v => {
                    this.scene.traverse(child => {
                        if (child.isMesh && child.material) {
                            child.material.wireframe = v;
                        }
                    });
                });
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
                if (this.dyno) this.dyno.resize();
            }

            animate(time) {
                requestAnimationFrame(this.animate.bind(this));

                const dt = (time - this.lastTime) / 1000;
                this.lastTime = time;

                const angularVelocity = (this.params.rpm * Math.PI * 2) / 60;
                this.crankAngle += angularVelocity * dt;
                this.crankAngle %= (Math.PI * 4);

                if (this.crankshaft) this.crankshaft.update(this.crankAngle);
                if (this.masterAssembly) this.masterAssembly.update(this.crankAngle);
                if (this.prop) this.prop.rotation.z = this.crankAngle;

                this.cylinders.forEach(cyl => {
                    cyl.update(this.crankAngle);
                });

                if (this.dyno) this.dyno.update(this.params.rpm);

                this.controls.autoRotate = this.params.autoRotate;
                this.controls.update();
                this.composer.render();
            }
        }

        new EngineSimulation();

    </script>
</body>

</html>